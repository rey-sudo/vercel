{"version":3,"file":"js/679.746cb1da.js","mappings":"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","sources":["webpack://frontend-home/./node_modules/lucid-cardano/esm/src/core/libs/cardano_message_signing/cardano_message_signing.generated.js"],"sourcesContent":["// @generated file from wasmbuild -- do not edit\n// deno-lint-ignore-file\n// deno-fmt-ignore-file\n// source-hash: ccea9a27c8aee355bc2051725d859ee0a31dcb77\nlet wasm;\nconst heap = new Array(128).fill(undefined);\nheap.push(undefined, null, true, false);\nfunction getObject(idx) {\n    return heap[idx];\n}\nlet heap_next = heap.length;\nfunction dropObject(idx) {\n    if (idx < 132)\n        return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\nconst cachedTextDecoder = new TextDecoder(\"utf-8\", {\n    ignoreBOM: true,\n    fatal: true,\n});\ncachedTextDecoder.decode();\nlet cachedUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length)\n        heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n    heap[idx] = obj;\n    return idx;\n}\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == \"number\" || type == \"boolean\" || val == null) {\n        return `${val}`;\n    }\n    if (type == \"string\") {\n        return `\"${val}\"`;\n    }\n    if (type == \"symbol\") {\n        const description = val.description;\n        if (description == null) {\n            return \"Symbol\";\n        }\n        else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == \"function\") {\n        const name = val.name;\n        if (typeof name == \"string\" && name.length > 0) {\n            return `Function(${name})`;\n        }\n        else {\n            return \"Function\";\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = \"[\";\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for (let i = 1; i < length; i++) {\n            debug += \", \" + debugString(val[i]);\n        }\n        debug += \"]\";\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    }\n    else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == \"Object\") {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return \"Object(\" + JSON.stringify(val) + \")\";\n        }\n        catch (_) {\n            return \"Object\";\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\nlet WASM_VECTOR_LEN = 0;\nconst cachedTextEncoder = new TextEncoder(\"utf-8\");\nconst encodeString = function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n};\nfunction passStringToWasm0(arg, malloc, realloc) {\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n    let len = arg.length;\n    let ptr = malloc(len);\n    const mem = getUint8Memory0();\n    let offset = 0;\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F)\n            break;\n        mem[ptr + offset] = code;\n    }\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n        offset += ret.written;\n    }\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\nlet cachedInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1);\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\nfunction getArrayU8FromWasm0(ptr, len) {\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\nlet cachedFloat64Memory0 = null;\nfunction getFloat64Memory0() {\n    if (cachedFloat64Memory0 === null || cachedFloat64Memory0.byteLength === 0) {\n        cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachedFloat64Memory0;\n}\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n/** */\nexport const AlgorithmId = Object.freeze({\n    /**\n     * r\" EdDSA (Pure EdDSA, not HashedEdDSA) - the algorithm used for Cardano addresses\n     */\n    EdDSA: 0,\n    \"0\": \"EdDSA\",\n    /**\n     * r\" ChaCha20/Poly1305 w/ 256-bit key, 128-bit tag\n     */\n    ChaCha20Poly1305: 1,\n    \"1\": \"ChaCha20Poly1305\",\n});\n/** */\nexport const KeyType = Object.freeze({\n    /**\n     * r\" octet key pair\n     */\n    OKP: 0,\n    \"0\": \"OKP\",\n    /**\n     * r\" 2-coord EC\n     */\n    EC2: 1,\n    \"1\": \"EC2\",\n    Symmetric: 2,\n    \"2\": \"Symmetric\",\n});\n/** */\nexport const ECKey = Object.freeze({\n    CRV: 0,\n    \"0\": \"CRV\",\n    X: 1,\n    \"1\": \"X\",\n    Y: 2,\n    \"2\": \"Y\",\n    D: 3,\n    \"3\": \"D\",\n});\n/** */\nexport const CurveType = Object.freeze({\n    P256: 0,\n    \"0\": \"P256\",\n    P384: 1,\n    \"1\": \"P384\",\n    P521: 2,\n    \"2\": \"P521\",\n    X25519: 3,\n    \"3\": \"X25519\",\n    X448: 4,\n    \"4\": \"X448\",\n    Ed25519: 5,\n    \"5\": \"Ed25519\",\n    Ed448: 6,\n    \"6\": \"Ed448\",\n});\n/** */\nexport const KeyOperation = Object.freeze({\n    Sign: 0,\n    \"0\": \"Sign\",\n    Verify: 1,\n    \"1\": \"Verify\",\n    Encrypt: 2,\n    \"2\": \"Encrypt\",\n    Decrypt: 3,\n    \"3\": \"Decrypt\",\n    WrapKey: 4,\n    \"4\": \"WrapKey\",\n    UnwrapKey: 5,\n    \"5\": \"UnwrapKey\",\n    DeriveKey: 6,\n    \"6\": \"DeriveKey\",\n    DeriveBits: 7,\n    \"7\": \"DeriveBits\",\n});\n/** */\nexport const CBORSpecialType = Object.freeze({\n    Bool: 0,\n    \"0\": \"Bool\",\n    Float: 1,\n    \"1\": \"Float\",\n    Unassigned: 2,\n    \"2\": \"Unassigned\",\n    Break: 3,\n    \"3\": \"Break\",\n    Undefined: 4,\n    \"4\": \"Undefined\",\n    Null: 5,\n    \"5\": \"Null\",\n});\n/** */\nexport const CBORValueKind = Object.freeze({\n    Int: 0,\n    \"0\": \"Int\",\n    Bytes: 1,\n    \"1\": \"Bytes\",\n    Text: 2,\n    \"2\": \"Text\",\n    Array: 3,\n    \"3\": \"Array\",\n    Object: 4,\n    \"4\": \"Object\",\n    TaggedCBOR: 5,\n    \"5\": \"TaggedCBOR\",\n    Special: 6,\n    \"6\": \"Special\",\n});\n/** */\nexport const LabelKind = Object.freeze({\n    Int: 0,\n    \"0\": \"Int\",\n    Text: 1,\n    \"1\": \"Text\",\n});\n/** */\nexport const SignedMessageKind = Object.freeze({\n    COSESIGN: 0,\n    \"0\": \"COSESIGN\",\n    COSESIGN1: 1,\n    \"1\": \"COSESIGN1\",\n});\n/** */\nexport const SigContext = Object.freeze({\n    Signature: 0,\n    \"0\": \"Signature\",\n    Signature1: 1,\n    \"1\": \"Signature1\",\n    CounterSignature: 2,\n    \"2\": \"CounterSignature\",\n});\nconst BigNumFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_bignum_free(ptr));\n/** */\nexport class BigNum {\n    static __wrap(ptr) {\n        const obj = Object.create(BigNum.prototype);\n        obj.ptr = ptr;\n        BigNumFinalization.register(obj, obj.ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        BigNumFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bignum_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bignum_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {BigNum}\n     */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.bignum_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BigNum.__wrap(r0);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {string} string\n     * @returns {BigNum}\n     */\n    static from_str(string) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(string, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.bignum_from_str(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BigNum.__wrap(r0);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {string}\n     */\n    to_str() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bignum_to_str(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n     * @param {BigNum} other\n     * @returns {BigNum}\n     */\n    checked_mul(other) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(other, BigNum);\n            wasm.bignum_checked_mul(retptr, this.ptr, other.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BigNum.__wrap(r0);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {BigNum} other\n     * @returns {BigNum}\n     */\n    checked_add(other) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(other, BigNum);\n            wasm.bignum_checked_add(retptr, this.ptr, other.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BigNum.__wrap(r0);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {BigNum} other\n     * @returns {BigNum}\n     */\n    checked_sub(other) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(other, BigNum);\n            wasm.bignum_checked_sub(retptr, this.ptr, other.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BigNum.__wrap(r0);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nconst CBORArrayFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_cborarray_free(ptr));\n/** */\nexport class CBORArray {\n    static __wrap(ptr) {\n        const obj = Object.create(CBORArray.prototype);\n        obj.ptr = ptr;\n        CBORArrayFinalization.register(obj, obj.ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        CBORArrayFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cborarray_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborarray_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {CBORArray}\n     */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.cborarray_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return CBORArray.__wrap(r0);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {CBORArray}\n     */\n    static new() {\n        const ret = wasm.cborarray_new();\n        return CBORArray.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    len() {\n        const ret = wasm.cborarray_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} index\n     * @returns {CBORValue}\n     */\n    get(index) {\n        const ret = wasm.cborarray_get(this.ptr, index);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n     * @param {CBORValue} elem\n     */\n    add(elem) {\n        _assertClass(elem, CBORValue);\n        wasm.cborarray_add(this.ptr, elem.ptr);\n    }\n    /**\n     * @param {boolean} use_definite\n     */\n    set_definite_encoding(use_definite) {\n        wasm.cborarray_set_definite_encoding(this.ptr, use_definite);\n    }\n    /**\n     * @returns {boolean}\n     */\n    is_definite() {\n        const ret = wasm.cborarray_is_definite(this.ptr);\n        return ret !== 0;\n    }\n}\nconst CBORObjectFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_cborobject_free(ptr));\n/** */\nexport class CBORObject {\n    static __wrap(ptr) {\n        const obj = Object.create(CBORObject.prototype);\n        obj.ptr = ptr;\n        CBORObjectFinalization.register(obj, obj.ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        CBORObjectFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cborobject_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborobject_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {CBORObject}\n     */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.cborobject_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return CBORObject.__wrap(r0);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {CBORObject}\n     */\n    static new() {\n        const ret = wasm.cborobject_new();\n        return CBORObject.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    len() {\n        const ret = wasm.cborobject_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {CBORValue} key\n     * @param {CBORValue} value\n     * @returns {CBORValue | undefined}\n     */\n    insert(key, value) {\n        _assertClass(key, CBORValue);\n        _assertClass(value, CBORValue);\n        const ret = wasm.cborobject_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : CBORValue.__wrap(ret);\n    }\n    /**\n     * @param {CBORValue} key\n     * @returns {CBORValue | undefined}\n     */\n    get(key) {\n        _assertClass(key, CBORValue);\n        const ret = wasm.cborobject_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : CBORValue.__wrap(ret);\n    }\n    /**\n     * @returns {CBORArray}\n     */\n    keys() {\n        const ret = wasm.cborobject_keys(this.ptr);\n        return CBORArray.__wrap(ret);\n    }\n    /**\n     * @param {boolean} use_definite\n     */\n    set_definite_encoding(use_definite) {\n        wasm.cborobject_set_definite_encoding(this.ptr, use_definite);\n    }\n    /**\n     * @returns {boolean}\n     */\n    is_definite() {\n        const ret = wasm.cborobject_is_definite(this.ptr);\n        return ret !== 0;\n    }\n}\nconst CBORSpecialFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_cborspecial_free(ptr));\n/** */\nexport class CBORSpecial {\n    static __wrap(ptr) {\n        const obj = Object.create(CBORSpecial.prototype);\n        obj.ptr = ptr;\n        CBORSpecialFinalization.register(obj, obj.ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        CBORSpecialFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cborspecial_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborspecial_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {CBORSpecial}\n     */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.cborspecial_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return CBORSpecial.__wrap(r0);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {boolean} b\n     * @returns {CBORSpecial}\n     */\n    static new_bool(b) {\n        const ret = wasm.cborspecial_new_bool(b);\n        return CBORSpecial.__wrap(ret);\n    }\n    /**\n     * @param {number} u\n     * @returns {CBORSpecial}\n     */\n    static new_unassigned(u) {\n        const ret = wasm.cborspecial_new_unassigned(u);\n        return CBORSpecial.__wrap(ret);\n    }\n    /**\n     * @returns {CBORSpecial}\n     */\n    static new_break() {\n        const ret = wasm.cborspecial_new_break();\n        return CBORSpecial.__wrap(ret);\n    }\n    /**\n     * @returns {CBORSpecial}\n     */\n    static new_null() {\n        const ret = wasm.cborspecial_new_null();\n        return CBORSpecial.__wrap(ret);\n    }\n    /**\n     * @returns {CBORSpecial}\n     */\n    static new_undefined() {\n        const ret = wasm.cborspecial_new_undefined();\n        return CBORSpecial.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    kind() {\n        const ret = wasm.cborspecial_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {boolean | undefined}\n     */\n    as_bool() {\n        const ret = wasm.cborspecial_as_bool(this.ptr);\n        return ret === 0xFFFFFF ? undefined : ret !== 0;\n    }\n    /**\n     * @returns {number | undefined}\n     */\n    as_float() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborspecial_as_float(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {number | undefined}\n     */\n    as_unassigned() {\n        const ret = wasm.cborspecial_as_unassigned(this.ptr);\n        return ret === 0xFFFFFF ? undefined : ret;\n    }\n}\nconst CBORValueFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_cborvalue_free(ptr));\n/** */\nexport class CBORValue {\n    static __wrap(ptr) {\n        const obj = Object.create(CBORValue.prototype);\n        obj.ptr = ptr;\n        CBORValueFinalization.register(obj, obj.ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        CBORValueFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cborvalue_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborvalue_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {CBORValue}\n     */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.cborvalue_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return CBORValue.__wrap(r0);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Int} int\n     * @returns {CBORValue}\n     */\n    static new_int(int) {\n        _assertClass(int, Int);\n        const ret = wasm.cborvalue_new_int(int.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {CBORValue}\n     */\n    static new_bytes(bytes) {\n        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.cborvalue_new_bytes(ptr0, len0);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n     * @param {string} text\n     * @returns {CBORValue}\n     */\n    static new_text(text) {\n        const ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.cborvalue_new_text(ptr0, len0);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n     * @param {CBORArray} arr\n     * @returns {CBORValue}\n     */\n    static new_array(arr) {\n        _assertClass(arr, CBORArray);\n        const ret = wasm.cborvalue_new_array(arr.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n     * @param {CBORObject} obj\n     * @returns {CBORValue}\n     */\n    static new_object(obj) {\n        _assertClass(obj, CBORObject);\n        const ret = wasm.cborvalue_new_object(obj.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n     * @param {TaggedCBOR} tagged\n     * @returns {CBORValue}\n     */\n    static new_tagged(tagged) {\n        _assertClass(tagged, TaggedCBOR);\n        const ret = wasm.cborvalue_new_tagged(tagged.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n     * @param {CBORSpecial} special\n     * @returns {CBORValue}\n     */\n    static new_special(special) {\n        _assertClass(special, CBORSpecial);\n        const ret = wasm.cborvalue_new_special(special.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n     * @param {Label} label\n     * @returns {CBORValue}\n     */\n    static from_label(label) {\n        _assertClass(label, Label);\n        const ret = wasm.cborvalue_from_label(label.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    kind() {\n        const ret = wasm.cborvalue_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {Int | undefined}\n     */\n    as_int() {\n        const ret = wasm.cborvalue_as_int(this.ptr);\n        return ret === 0 ? undefined : Int.__wrap(ret);\n    }\n    /**\n     * @returns {Uint8Array | undefined}\n     */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborvalue_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {string | undefined}\n     */\n    as_text() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborvalue_as_text(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getStringFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {CBORArray | undefined}\n     */\n    as_array() {\n        const ret = wasm.cborvalue_as_array(this.ptr);\n        return ret === 0 ? undefined : CBORArray.__wrap(ret);\n    }\n    /**\n     * @returns {CBORObject | undefined}\n     */\n    as_object() {\n        const ret = wasm.cborvalue_as_object(this.ptr);\n        return ret === 0 ? undefined : CBORObject.__wrap(ret);\n    }\n    /**\n     * @returns {TaggedCBOR | undefined}\n     */\n    as_tagged() {\n        const ret = wasm.cborvalue_as_tagged(this.ptr);\n        return ret === 0 ? undefined : TaggedCBOR.__wrap(ret);\n    }\n    /**\n     * @returns {CBORSpecial | undefined}\n     */\n    as_special() {\n        const ret = wasm.cborvalue_as_special(this.ptr);\n        return ret === 0 ? undefined : CBORSpecial.__wrap(ret);\n    }\n}\nconst COSEEncryptFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_coseencrypt_free(ptr));\n/** */\nexport class COSEEncrypt {\n    static __wrap(ptr) {\n        const obj = Object.create(COSEEncrypt.prototype);\n        obj.ptr = ptr;\n        COSEEncryptFinalization.register(obj, obj.ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        COSEEncryptFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_coseencrypt_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {COSEEncrypt}\n     */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.coseencrypt_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return COSEEncrypt.__wrap(r0);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Headers}\n     */\n    headers() {\n        const ret = wasm.coseencrypt0_headers(this.ptr);\n        return Headers.__wrap(ret);\n    }\n    /**\n     * @returns {Uint8Array | undefined}\n     */\n    ciphertext() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt0_ciphertext(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {COSERecipients}\n     */\n    recipients() {\n        const ret = wasm.coseencrypt_recipients(this.ptr);\n        return COSERecipients.__wrap(ret);\n    }\n    /**\n     * @param {Headers} headers\n     * @param {Uint8Array | undefined} ciphertext\n     * @param {COSERecipients} recipients\n     * @returns {COSEEncrypt}\n     */\n    static new(headers, ciphertext, recipients) {\n        _assertClass(headers, Headers);\n        var ptr0 = isLikeNone(ciphertext)\n            ? 0\n            : passArray8ToWasm0(ciphertext, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        _assertClass(recipients, COSERecipients);\n        const ret = wasm.coseencrypt_new(headers.ptr, ptr0, len0, recipients.ptr);\n        return COSEEncrypt.__wrap(ret);\n    }\n}\nconst COSEEncrypt0Finalization = new FinalizationRegistry((ptr) => wasm.__wbg_coseencrypt0_free(ptr));\n/** */\nexport class COSEEncrypt0 {\n    static __wrap(ptr) {\n        const obj = Object.create(COSEEncrypt0.prototype);\n        obj.ptr = ptr;\n        COSEEncrypt0Finalization.register(obj, obj.ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        COSEEncrypt0Finalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_coseencrypt0_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt0_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {COSEEncrypt0}\n     */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.coseencrypt0_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return COSEEncrypt0.__wrap(r0);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Headers}\n     */\n    headers() {\n        const ret = wasm.coseencrypt0_headers(this.ptr);\n        return Headers.__wrap(ret);\n    }\n    /**\n     * @returns {Uint8Array | undefined}\n     */\n    ciphertext() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt0_ciphertext(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Headers} headers\n     * @param {Uint8Array | undefined} ciphertext\n     * @returns {COSEEncrypt0}\n     */\n    static new(headers, ciphertext) {\n        _assertClass(headers, Headers);\n        var ptr0 = isLikeNone(ciphertext)\n            ? 0\n            : passArray8ToWasm0(ciphertext, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.coseencrypt0_new(headers.ptr, ptr0, len0);\n        return COSEEncrypt0.__wrap(ret);\n    }\n}\nconst COSEKeyFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_cosekey_free(ptr));\n/** */\nexport class COSEKey {\n    static __wrap(ptr) {\n        const obj = Object.create(COSEKey.prototype);\n        obj.ptr = ptr;\n        COSEKeyFinalization.register(obj, obj.ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        COSEKeyFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosekey_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosekey_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {COSEKey}\n     */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.cosekey_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return COSEKey.__wrap(r0);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Label} key_type\n     */\n    set_key_type(key_type) {\n        _assertClass(key_type, Label);\n        wasm.cosekey_set_key_type(this.ptr, key_type.ptr);\n    }\n    /**\n     * @returns {Label}\n     */\n    key_type() {\n        const ret = wasm.cosekey_key_type(this.ptr);\n        return Label.__wrap(ret);\n    }\n    /**\n     * @param {Uint8Array} key_id\n     */\n    set_key_id(key_id) {\n        const ptr0 = passArray8ToWasm0(key_id, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.cosekey_set_key_id(this.ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array | undefined}\n     */\n    key_id() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosekey_key_id(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Label} algorithm_id\n     */\n    set_algorithm_id(algorithm_id) {\n        _assertClass(algorithm_id, Label);\n        wasm.cosekey_set_algorithm_id(this.ptr, algorithm_id.ptr);\n    }\n    /**\n     * @returns {Label | undefined}\n     */\n    algorithm_id() {\n        const ret = wasm.cosekey_algorithm_id(this.ptr);\n        return ret === 0 ? undefined : Label.__wrap(ret);\n    }\n    /**\n     * @param {Labels} key_ops\n     */\n    set_key_ops(key_ops) {\n        _assertClass(key_ops, Labels);\n        wasm.cosekey_set_key_ops(this.ptr, key_ops.ptr);\n    }\n    /**\n     * @returns {Labels | undefined}\n     */\n    key_ops() {\n        const ret = wasm.cosekey_key_ops(this.ptr);\n        return ret === 0 ? undefined : Labels.__wrap(ret);\n    }\n    /**\n     * @param {Uint8Array} base_init_vector\n     */\n    set_base_init_vector(base_init_vector) {\n        const ptr0 = passArray8ToWasm0(base_init_vector, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.cosekey_set_base_init_vector(this.ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array | undefined}\n     */\n    base_init_vector() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosekey_base_init_vector(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Label} label\n     * @returns {CBORValue | undefined}\n     */\n    header(label) {\n        _assertClass(label, Label);\n        const ret = wasm.cosekey_header(this.ptr, label.ptr);\n        return ret === 0 ? undefined : CBORValue.__wrap(ret);\n    }\n    /**\n     * @param {Label} label\n     * @param {CBORValue} value\n     */\n    set_header(label, value) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(label, Label);\n            _assertClass(value, CBORValue);\n            wasm.cosekey_set_header(retptr, this.ptr, label.ptr, value.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Label} key_type\n     * @returns {COSEKey}\n     */\n    static new(key_type) {\n        _assertClass(key_type, Label);\n        const ret = wasm.cosekey_new(key_type.ptr);\n        return COSEKey.__wrap(ret);\n    }\n}\nconst COSERecipientFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_coserecipient_free(ptr));\n/** */\nexport class COSERecipient {\n    static __wrap(ptr) {\n        const obj = Object.create(COSERecipient.prototype);\n        obj.ptr = ptr;\n        COSERecipientFinalization.register(obj, obj.ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        COSERecipientFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_coserecipient_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coserecipient_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {COSERecipient}\n     */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.coserecipient_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return COSERecipient.__wrap(r0);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Headers}\n     */\n    headers() {\n        const ret = wasm.coseencrypt0_headers(this.ptr);\n        return Headers.__wrap(ret);\n    }\n    /**\n     * @returns {Uint8Array | undefined}\n     */\n    ciphertext() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt0_ciphertext(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Headers} headers\n     * @param {Uint8Array | undefined} ciphertext\n     * @returns {COSERecipient}\n     */\n    static new(headers, ciphertext) {\n        _assertClass(headers, Headers);\n        var ptr0 = isLikeNone(ciphertext)\n            ? 0\n            : passArray8ToWasm0(ciphertext, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.coseencrypt0_new(headers.ptr, ptr0, len0);\n        return COSERecipient.__wrap(ret);\n    }\n}\nconst COSERecipientsFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_coserecipients_free(ptr));\n/** */\nexport class COSERecipients {\n    static __wrap(ptr) {\n        const obj = Object.create(COSERecipients.prototype);\n        obj.ptr = ptr;\n        COSERecipientsFinalization.register(obj, obj.ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        COSERecipientsFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_coserecipients_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coserecipients_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {COSERecipients}\n     */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.coserecipients_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return COSERecipients.__wrap(r0);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {COSERecipients}\n     */\n    static new() {\n        const ret = wasm.coserecipients_new();\n        return COSERecipients.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    len() {\n        const ret = wasm.cborarray_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} index\n     * @returns {COSERecipient}\n     */\n    get(index) {\n        const ret = wasm.coserecipients_get(this.ptr, index);\n        return COSERecipient.__wrap(ret);\n    }\n    /**\n     * @param {COSERecipient} elem\n     */\n    add(elem) {\n        _assertClass(elem, COSERecipient);\n        wasm.coserecipients_add(this.ptr, elem.ptr);\n    }\n}\nconst COSESignFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_cosesign_free(ptr));\n/** */\nexport class COSESign {\n    static __wrap(ptr) {\n        const obj = Object.create(COSESign.prototype);\n        obj.ptr = ptr;\n        COSESignFinalization.register(obj, obj.ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        COSESignFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosesign_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosesign_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {COSESign}\n     */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.cosesign_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return COSESign.__wrap(r0);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Headers}\n     */\n    headers() {\n        const ret = wasm.coseencrypt0_headers(this.ptr);\n        return Headers.__wrap(ret);\n    }\n    /**\n     * @returns {Uint8Array | undefined}\n     */\n    payload() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt0_ciphertext(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {COSESignatures}\n     */\n    signatures() {\n        const ret = wasm.cosesign_signatures(this.ptr);\n        return COSESignatures.__wrap(ret);\n    }\n    /**\n     * @param {Headers} headers\n     * @param {Uint8Array | undefined} payload\n     * @param {COSESignatures} signatures\n     * @returns {COSESign}\n     */\n    static new(headers, payload, signatures) {\n        _assertClass(headers, Headers);\n        var ptr0 = isLikeNone(payload)\n            ? 0\n            : passArray8ToWasm0(payload, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        _assertClass(signatures, COSESignatures);\n        const ret = wasm.cosesign_new(headers.ptr, ptr0, len0, signatures.ptr);\n        return COSESign.__wrap(ret);\n    }\n}\nconst COSESign1Finalization = new FinalizationRegistry((ptr) => wasm.__wbg_cosesign1_free(ptr));\n/** */\nexport class COSESign1 {\n    static __wrap(ptr) {\n        const obj = Object.create(COSESign1.prototype);\n        obj.ptr = ptr;\n        COSESign1Finalization.register(obj, obj.ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        COSESign1Finalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosesign1_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosesign1_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {COSESign1}\n     */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.cosesign1_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return COSESign1.__wrap(r0);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Headers}\n     */\n    headers() {\n        const ret = wasm.coseencrypt0_headers(this.ptr);\n        return Headers.__wrap(ret);\n    }\n    /**\n     * @returns {Uint8Array | undefined}\n     */\n    payload() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt0_ciphertext(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    signature() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosesign1_signature(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * For verifying, we will want to reverse-construct this SigStructure to check the signature against\n     * # Arguments\n     * * `external_aad` - External application data - see RFC 8152 section 4.3. Set to None if not using this.\n     * @param {Uint8Array | undefined} external_aad\n     * @param {Uint8Array | undefined} external_payload\n     * @returns {SigStructure}\n     */\n    signed_data(external_aad, external_payload) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = isLikeNone(external_aad)\n                ? 0\n                : passArray8ToWasm0(external_aad, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            var ptr1 = isLikeNone(external_payload)\n                ? 0\n                : passArray8ToWasm0(external_payload, wasm.__wbindgen_malloc);\n            var len1 = WASM_VECTOR_LEN;\n            wasm.cosesign1_signed_data(retptr, this.ptr, ptr0, len0, ptr1, len1);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return SigStructure.__wrap(r0);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Headers} headers\n     * @param {Uint8Array | undefined} payload\n     * @param {Uint8Array} signature\n     * @returns {COSESign1}\n     */\n    static new(headers, payload, signature) {\n        _assertClass(headers, Headers);\n        var ptr0 = isLikeNone(payload)\n            ? 0\n            : passArray8ToWasm0(payload, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray8ToWasm0(signature, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.cosesign1_new(headers.ptr, ptr0, len0, ptr1, len1);\n        return COSESign1.__wrap(ret);\n    }\n}\nconst COSESign1BuilderFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_cosesign1builder_free(ptr));\n/** */\nexport class COSESign1Builder {\n    static __wrap(ptr) {\n        const obj = Object.create(COSESign1Builder.prototype);\n        obj.ptr = ptr;\n        COSESign1BuilderFinalization.register(obj, obj.ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        COSESign1BuilderFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosesign1builder_free(ptr);\n    }\n    /**\n     * @param {Headers} headers\n     * @param {Uint8Array} payload\n     * @param {boolean} is_payload_external\n     * @returns {COSESign1Builder}\n     */\n    static new(headers, payload, is_payload_external) {\n        _assertClass(headers, Headers);\n        const ptr0 = passArray8ToWasm0(payload, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.cosesign1builder_new(headers.ptr, ptr0, len0, is_payload_external);\n        return COSESign1Builder.__wrap(ret);\n    }\n    /** */\n    hash_payload() {\n        wasm.cosesign1builder_hash_payload(this.ptr);\n    }\n    /**\n     * @param {Uint8Array} external_aad\n     */\n    set_external_aad(external_aad) {\n        const ptr0 = passArray8ToWasm0(external_aad, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.cosesign1builder_set_external_aad(this.ptr, ptr0, len0);\n    }\n    /**\n     * @returns {SigStructure}\n     */\n    make_data_to_sign() {\n        const ret = wasm.cosesign1builder_make_data_to_sign(this.ptr);\n        return SigStructure.__wrap(ret);\n    }\n    /**\n     * @param {Uint8Array} signed_sig_structure\n     * @returns {COSESign1}\n     */\n    build(signed_sig_structure) {\n        const ptr0 = passArray8ToWasm0(signed_sig_structure, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.cosesign1builder_build(this.ptr, ptr0, len0);\n        return COSESign1.__wrap(ret);\n    }\n}\nconst COSESignBuilderFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_cosesignbuilder_free(ptr));\n/** */\nexport class COSESignBuilder {\n    static __wrap(ptr) {\n        const obj = Object.create(COSESignBuilder.prototype);\n        obj.ptr = ptr;\n        COSESignBuilderFinalization.register(obj, obj.ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        COSESignBuilderFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosesignbuilder_free(ptr);\n    }\n    /**\n     * @param {Headers} headers\n     * @param {Uint8Array} payload\n     * @param {boolean} is_payload_external\n     * @returns {COSESignBuilder}\n     */\n    static new(headers, payload, is_payload_external) {\n        _assertClass(headers, Headers);\n        const ptr0 = passArray8ToWasm0(payload, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.cosesignbuilder_new(headers.ptr, ptr0, len0, is_payload_external);\n        return COSESignBuilder.__wrap(ret);\n    }\n    /** */\n    hash_payload() {\n        wasm.cosesign1builder_hash_payload(this.ptr);\n    }\n    /**\n     * @param {Uint8Array} external_aad\n     */\n    set_external_aad(external_aad) {\n        const ptr0 = passArray8ToWasm0(external_aad, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.cosesign1builder_set_external_aad(this.ptr, ptr0, len0);\n    }\n    /**\n     * @returns {SigStructure}\n     */\n    make_data_to_sign() {\n        const ret = wasm.cosesignbuilder_make_data_to_sign(this.ptr);\n        return SigStructure.__wrap(ret);\n    }\n    /**\n     * @param {COSESignatures} signed_sig_structure\n     * @returns {COSESign}\n     */\n    build(signed_sig_structure) {\n        _assertClass(signed_sig_structure, COSESignatures);\n        const ret = wasm.cosesignbuilder_build(this.ptr, signed_sig_structure.ptr);\n        return COSESign.__wrap(ret);\n    }\n}\nconst COSESignatureFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_cosesignature_free(ptr));\n/** */\nexport class COSESignature {\n    static __wrap(ptr) {\n        const obj = Object.create(COSESignature.prototype);\n        obj.ptr = ptr;\n        COSESignatureFinalization.register(obj, obj.ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        COSESignatureFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosesignature_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosesignature_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {COSESignature}\n     */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.cosesignature_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return COSESignature.__wrap(r0);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Headers}\n     */\n    headers() {\n        const ret = wasm.coseencrypt0_headers(this.ptr);\n        return Headers.__wrap(ret);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    signature() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosesignature_signature(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Headers} headers\n     * @param {Uint8Array} signature\n     * @returns {COSESignature}\n     */\n    static new(headers, signature) {\n        _assertClass(headers, Headers);\n        const ptr0 = passArray8ToWasm0(signature, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.cosesignature_new(headers.ptr, ptr0, len0);\n        return COSESignature.__wrap(ret);\n    }\n}\nconst COSESignaturesFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_cosesignatures_free(ptr));\n/** */\nexport class COSESignatures {\n    static __wrap(ptr) {\n        const obj = Object.create(COSESignatures.prototype);\n        obj.ptr = ptr;\n        COSESignaturesFinalization.register(obj, obj.ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        COSESignaturesFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosesignatures_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosesignatures_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {COSESignatures}\n     */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.cosesignatures_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return COSESignatures.__wrap(r0);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {COSESignatures}\n     */\n    static new() {\n        const ret = wasm.coserecipients_new();\n        return COSESignatures.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    len() {\n        const ret = wasm.cborarray_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} index\n     * @returns {COSESignature}\n     */\n    get(index) {\n        const ret = wasm.cosesignatures_get(this.ptr, index);\n        return COSESignature.__wrap(ret);\n    }\n    /**\n     * @param {COSESignature} elem\n     */\n    add(elem) {\n        _assertClass(elem, COSESignature);\n        wasm.cosesignatures_add(this.ptr, elem.ptr);\n    }\n}\nconst CounterSignatureFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_countersignature_free(ptr));\n/** */\nexport class CounterSignature {\n    static __wrap(ptr) {\n        const obj = Object.create(CounterSignature.prototype);\n        obj.ptr = ptr;\n        CounterSignatureFinalization.register(obj, obj.ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        CounterSignatureFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_countersignature_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.countersignature_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {CounterSignature}\n     */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.countersignature_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return CounterSignature.__wrap(r0);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {COSESignature} cose_signature\n     * @returns {CounterSignature}\n     */\n    static new_single(cose_signature) {\n        _assertClass(cose_signature, COSESignature);\n        const ret = wasm.countersignature_new_single(cose_signature.ptr);\n        return CounterSignature.__wrap(ret);\n    }\n    /**\n     * @param {COSESignatures} cose_signatures\n     * @returns {CounterSignature}\n     */\n    static new_multi(cose_signatures) {\n        _assertClass(cose_signatures, COSESignatures);\n        const ret = wasm.countersignature_new_multi(cose_signatures.ptr);\n        return CounterSignature.__wrap(ret);\n    }\n    /**\n     * @returns {COSESignatures}\n     */\n    signatures() {\n        const ret = wasm.countersignature_signatures(this.ptr);\n        return COSESignatures.__wrap(ret);\n    }\n}\nconst EdDSA25519KeyFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_eddsa25519key_free(ptr));\n/** */\nexport class EdDSA25519Key {\n    static __wrap(ptr) {\n        const obj = Object.create(EdDSA25519Key.prototype);\n        obj.ptr = ptr;\n        EdDSA25519KeyFinalization.register(obj, obj.ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        EdDSA25519KeyFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_eddsa25519key_free(ptr);\n    }\n    /**\n     * @param {Uint8Array} pubkey_bytes\n     * @returns {EdDSA25519Key}\n     */\n    static new(pubkey_bytes) {\n        const ptr0 = passArray8ToWasm0(pubkey_bytes, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.eddsa25519key_new(ptr0, len0);\n        return EdDSA25519Key.__wrap(ret);\n    }\n    /**\n     * @param {Uint8Array} private_key_bytes\n     */\n    set_private_key(private_key_bytes) {\n        const ptr0 = passArray8ToWasm0(private_key_bytes, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.eddsa25519key_set_private_key(this.ptr, ptr0, len0);\n    }\n    /** */\n    is_for_signing() {\n        wasm.eddsa25519key_is_for_signing(this.ptr);\n    }\n    /** */\n    is_for_verifying() {\n        wasm.eddsa25519key_is_for_verifying(this.ptr);\n    }\n    /**\n     * @returns {COSEKey}\n     */\n    build() {\n        const ret = wasm.eddsa25519key_build(this.ptr);\n        return COSEKey.__wrap(ret);\n    }\n}\nconst HeaderMapFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_headermap_free(ptr));\n/** */\nexport class HeaderMap {\n    static __wrap(ptr) {\n        const obj = Object.create(HeaderMap.prototype);\n        obj.ptr = ptr;\n        HeaderMapFinalization.register(obj, obj.ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        HeaderMapFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_headermap_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.headermap_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {HeaderMap}\n     */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.headermap_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return HeaderMap.__wrap(r0);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Label} algorithm_id\n     */\n    set_algorithm_id(algorithm_id) {\n        _assertClass(algorithm_id, Label);\n        wasm.headermap_set_algorithm_id(this.ptr, algorithm_id.ptr);\n    }\n    /**\n     * @returns {Label | undefined}\n     */\n    algorithm_id() {\n        const ret = wasm.headermap_algorithm_id(this.ptr);\n        return ret === 0 ? undefined : Label.__wrap(ret);\n    }\n    /**\n     * @param {Labels} criticality\n     */\n    set_criticality(criticality) {\n        _assertClass(criticality, Labels);\n        wasm.headermap_set_criticality(this.ptr, criticality.ptr);\n    }\n    /**\n     * @returns {Labels | undefined}\n     */\n    criticality() {\n        const ret = wasm.headermap_criticality(this.ptr);\n        return ret === 0 ? undefined : Labels.__wrap(ret);\n    }\n    /**\n     * @param {Label} content_type\n     */\n    set_content_type(content_type) {\n        _assertClass(content_type, Label);\n        wasm.headermap_set_content_type(this.ptr, content_type.ptr);\n    }\n    /**\n     * @returns {Label | undefined}\n     */\n    content_type() {\n        const ret = wasm.headermap_content_type(this.ptr);\n        return ret === 0 ? undefined : Label.__wrap(ret);\n    }\n    /**\n     * @param {Uint8Array} key_id\n     */\n    set_key_id(key_id) {\n        const ptr0 = passArray8ToWasm0(key_id, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.headermap_set_key_id(this.ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array | undefined}\n     */\n    key_id() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.headermap_key_id(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} init_vector\n     */\n    set_init_vector(init_vector) {\n        const ptr0 = passArray8ToWasm0(init_vector, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.cosekey_set_base_init_vector(this.ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array | undefined}\n     */\n    init_vector() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosekey_base_init_vector(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} partial_init_vector\n     */\n    set_partial_init_vector(partial_init_vector) {\n        const ptr0 = passArray8ToWasm0(partial_init_vector, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.headermap_set_partial_init_vector(this.ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array | undefined}\n     */\n    partial_init_vector() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.headermap_partial_init_vector(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {CounterSignature} counter_signature\n     */\n    set_counter_signature(counter_signature) {\n        _assertClass(counter_signature, CounterSignature);\n        wasm.headermap_set_counter_signature(this.ptr, counter_signature.ptr);\n    }\n    /**\n     * @returns {CounterSignature | undefined}\n     */\n    counter_signature() {\n        const ret = wasm.headermap_counter_signature(this.ptr);\n        return ret === 0 ? undefined : CounterSignature.__wrap(ret);\n    }\n    /**\n     * @param {Label} label\n     * @returns {CBORValue | undefined}\n     */\n    header(label) {\n        _assertClass(label, Label);\n        const ret = wasm.headermap_header(this.ptr, label.ptr);\n        return ret === 0 ? undefined : CBORValue.__wrap(ret);\n    }\n    /**\n     * @param {Label} label\n     * @param {CBORValue} value\n     */\n    set_header(label, value) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(label, Label);\n            _assertClass(value, CBORValue);\n            wasm.headermap_set_header(retptr, this.ptr, label.ptr, value.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Labels}\n     */\n    keys() {\n        const ret = wasm.headermap_keys(this.ptr);\n        return Labels.__wrap(ret);\n    }\n    /**\n     * @returns {HeaderMap}\n     */\n    static new() {\n        const ret = wasm.headermap_new();\n        return HeaderMap.__wrap(ret);\n    }\n}\nconst HeadersFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_headers_free(ptr));\n/** */\nexport class Headers {\n    static __wrap(ptr) {\n        const obj = Object.create(Headers.prototype);\n        obj.ptr = ptr;\n        HeadersFinalization.register(obj, obj.ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        HeadersFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_headers_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.headers_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {Headers}\n     */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.headers_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Headers.__wrap(r0);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {ProtectedHeaderMap}\n     */\n    protected() {\n        const ret = wasm.headers_protected(this.ptr);\n        return ProtectedHeaderMap.__wrap(ret);\n    }\n    /**\n     * @returns {HeaderMap}\n     */\n    unprotected() {\n        const ret = wasm.headers_unprotected(this.ptr);\n        return HeaderMap.__wrap(ret);\n    }\n    /**\n     * @param {ProtectedHeaderMap} protected_\n     * @param {HeaderMap} unprotected_\n     * @returns {Headers}\n     */\n    static new(protected_, unprotected_) {\n        _assertClass(protected_, ProtectedHeaderMap);\n        _assertClass(unprotected_, HeaderMap);\n        const ret = wasm.headers_new(protected_.ptr, unprotected_.ptr);\n        return Headers.__wrap(ret);\n    }\n}\nconst IntFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_int_free(ptr));\n/** */\nexport class Int {\n    static __wrap(ptr) {\n        const obj = Object.create(Int.prototype);\n        obj.ptr = ptr;\n        IntFinalization.register(obj, obj.ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        IntFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_int_free(ptr);\n    }\n    /**\n     * @param {BigNum} x\n     * @returns {Int}\n     */\n    static new(x) {\n        _assertClass(x, BigNum);\n        var ptr0 = x.__destroy_into_raw();\n        const ret = wasm.int_new(ptr0);\n        return Int.__wrap(ret);\n    }\n    /**\n     * @param {BigNum} x\n     * @returns {Int}\n     */\n    static new_negative(x) {\n        _assertClass(x, BigNum);\n        var ptr0 = x.__destroy_into_raw();\n        const ret = wasm.int_new_negative(ptr0);\n        return Int.__wrap(ret);\n    }\n    /**\n     * @param {number} x\n     * @returns {Int}\n     */\n    static new_i32(x) {\n        const ret = wasm.int_new_i32(x);\n        return Int.__wrap(ret);\n    }\n    /**\n     * @returns {boolean}\n     */\n    is_positive() {\n        const ret = wasm.int_is_positive(this.ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {BigNum | undefined}\n     */\n    as_positive() {\n        const ret = wasm.int_as_positive(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n     * @returns {BigNum | undefined}\n     */\n    as_negative() {\n        const ret = wasm.int_as_negative(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n     * @returns {number | undefined}\n     */\n    as_i32() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.int_as_i32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nconst LabelFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_label_free(ptr));\n/** */\nexport class Label {\n    static __wrap(ptr) {\n        const obj = Object.create(Label.prototype);\n        obj.ptr = ptr;\n        LabelFinalization.register(obj, obj.ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        LabelFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_label_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.label_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {Label}\n     */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.label_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Label.__wrap(r0);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Int} int\n     * @returns {Label}\n     */\n    static new_int(int) {\n        _assertClass(int, Int);\n        const ret = wasm.label_new_int(int.ptr);\n        return Label.__wrap(ret);\n    }\n    /**\n     * @param {string} text\n     * @returns {Label}\n     */\n    static new_text(text) {\n        const ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.label_new_text(ptr0, len0);\n        return Label.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    kind() {\n        const ret = wasm.label_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {Int | undefined}\n     */\n    as_int() {\n        const ret = wasm.label_as_int(this.ptr);\n        return ret === 0 ? undefined : Int.__wrap(ret);\n    }\n    /**\n     * @returns {string | undefined}\n     */\n    as_text() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.label_as_text(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getStringFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} id\n     * @returns {Label}\n     */\n    static from_algorithm_id(id) {\n        const ret = wasm.label_from_algorithm_id(id);\n        return Label.__wrap(ret);\n    }\n    /**\n     * @param {number} key_type\n     * @returns {Label}\n     */\n    static from_key_type(key_type) {\n        const ret = wasm.label_from_key_type(key_type);\n        return Label.__wrap(ret);\n    }\n    /**\n     * @param {number} ec_key\n     * @returns {Label}\n     */\n    static from_ec_key(ec_key) {\n        const ret = wasm.label_from_ec_key(ec_key);\n        return Label.__wrap(ret);\n    }\n    /**\n     * @param {number} curve_type\n     * @returns {Label}\n     */\n    static from_curve_type(curve_type) {\n        const ret = wasm.label_from_curve_type(curve_type);\n        return Label.__wrap(ret);\n    }\n    /**\n     * @param {number} key_op\n     * @returns {Label}\n     */\n    static from_key_operation(key_op) {\n        const ret = wasm.label_from_key_operation(key_op);\n        return Label.__wrap(ret);\n    }\n}\nconst LabelsFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_labels_free(ptr));\n/** */\nexport class Labels {\n    static __wrap(ptr) {\n        const obj = Object.create(Labels.prototype);\n        obj.ptr = ptr;\n        LabelsFinalization.register(obj, obj.ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        LabelsFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_labels_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.labels_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {Labels}\n     */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.labels_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Labels.__wrap(r0);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Labels}\n     */\n    static new() {\n        const ret = wasm.coserecipients_new();\n        return Labels.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    len() {\n        const ret = wasm.cborarray_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} index\n     * @returns {Label}\n     */\n    get(index) {\n        const ret = wasm.labels_get(this.ptr, index);\n        return Label.__wrap(ret);\n    }\n    /**\n     * @param {Label} elem\n     */\n    add(elem) {\n        _assertClass(elem, Label);\n        wasm.labels_add(this.ptr, elem.ptr);\n    }\n}\nconst PasswordEncryptionFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_passwordencryption_free(ptr));\n/** */\nexport class PasswordEncryption {\n    static __wrap(ptr) {\n        const obj = Object.create(PasswordEncryption.prototype);\n        obj.ptr = ptr;\n        PasswordEncryptionFinalization.register(obj, obj.ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        PasswordEncryptionFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_passwordencryption_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.passwordencryption_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {PasswordEncryption}\n     */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.passwordencryption_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PasswordEncryption.__wrap(r0);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {COSEEncrypt0} data\n     * @returns {PasswordEncryption}\n     */\n    static new(data) {\n        _assertClass(data, COSEEncrypt0);\n        const ret = wasm.passwordencryption_new(data.ptr);\n        return PasswordEncryption.__wrap(ret);\n    }\n}\nconst ProtectedHeaderMapFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_protectedheadermap_free(ptr));\n/** */\nexport class ProtectedHeaderMap {\n    static __wrap(ptr) {\n        const obj = Object.create(ProtectedHeaderMap.prototype);\n        obj.ptr = ptr;\n        ProtectedHeaderMapFinalization.register(obj, obj.ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        ProtectedHeaderMapFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_protectedheadermap_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protectedheadermap_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {ProtectedHeaderMap}\n     */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.protectedheadermap_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ProtectedHeaderMap.__wrap(r0);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {ProtectedHeaderMap}\n     */\n    static new_empty() {\n        const ret = wasm.protectedheadermap_new_empty();\n        return ProtectedHeaderMap.__wrap(ret);\n    }\n    /**\n     * @param {HeaderMap} header_map\n     * @returns {ProtectedHeaderMap}\n     */\n    static new(header_map) {\n        _assertClass(header_map, HeaderMap);\n        const ret = wasm.protectedheadermap_new(header_map.ptr);\n        return ProtectedHeaderMap.__wrap(ret);\n    }\n    /**\n     * @returns {HeaderMap}\n     */\n    deserialized_headers() {\n        const ret = wasm.protectedheadermap_deserialized_headers(this.ptr);\n        return HeaderMap.__wrap(ret);\n    }\n}\nconst PubKeyEncryptionFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_pubkeyencryption_free(ptr));\n/** */\nexport class PubKeyEncryption {\n    static __wrap(ptr) {\n        const obj = Object.create(PubKeyEncryption.prototype);\n        obj.ptr = ptr;\n        PubKeyEncryptionFinalization.register(obj, obj.ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        PubKeyEncryptionFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_pubkeyencryption_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.pubkeyencryption_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {PubKeyEncryption}\n     */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.pubkeyencryption_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PubKeyEncryption.__wrap(r0);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {COSEEncrypt} data\n     * @returns {PubKeyEncryption}\n     */\n    static new(data) {\n        _assertClass(data, COSEEncrypt);\n        const ret = wasm.pubkeyencryption_new(data.ptr);\n        return PubKeyEncryption.__wrap(ret);\n    }\n}\nconst SigStructureFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_sigstructure_free(ptr));\n/** */\nexport class SigStructure {\n    static __wrap(ptr) {\n        const obj = Object.create(SigStructure.prototype);\n        obj.ptr = ptr;\n        SigStructureFinalization.register(obj, obj.ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        SigStructureFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_sigstructure_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.sigstructure_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {SigStructure}\n     */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.sigstructure_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return SigStructure.__wrap(r0);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {number}\n     */\n    context() {\n        const ret = wasm.sigstructure_context(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {ProtectedHeaderMap}\n     */\n    body_protected() {\n        const ret = wasm.sigstructure_body_protected(this.ptr);\n        return ProtectedHeaderMap.__wrap(ret);\n    }\n    /**\n     * @returns {ProtectedHeaderMap | undefined}\n     */\n    sign_protected() {\n        const ret = wasm.sigstructure_sign_protected(this.ptr);\n        return ret === 0 ? undefined : ProtectedHeaderMap.__wrap(ret);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    external_aad() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.sigstructure_external_aad(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    payload() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.sigstructure_payload(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {ProtectedHeaderMap} sign_protected\n     */\n    set_sign_protected(sign_protected) {\n        _assertClass(sign_protected, ProtectedHeaderMap);\n        wasm.sigstructure_set_sign_protected(this.ptr, sign_protected.ptr);\n    }\n    /**\n     * @param {number} context\n     * @param {ProtectedHeaderMap} body_protected\n     * @param {Uint8Array} external_aad\n     * @param {Uint8Array} payload\n     * @returns {SigStructure}\n     */\n    static new(context, body_protected, external_aad, payload) {\n        _assertClass(body_protected, ProtectedHeaderMap);\n        const ptr0 = passArray8ToWasm0(external_aad, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray8ToWasm0(payload, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.sigstructure_new(context, body_protected.ptr, ptr0, len0, ptr1, len1);\n        return SigStructure.__wrap(ret);\n    }\n}\nconst SignedMessageFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_signedmessage_free(ptr));\n/** */\nexport class SignedMessage {\n    static __wrap(ptr) {\n        const obj = Object.create(SignedMessage.prototype);\n        obj.ptr = ptr;\n        SignedMessageFinalization.register(obj, obj.ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        SignedMessageFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_signedmessage_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signedmessage_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {SignedMessage}\n     */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.signedmessage_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return SignedMessage.__wrap(r0);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {COSESign} cose_sign\n     * @returns {SignedMessage}\n     */\n    static new_cose_sign(cose_sign) {\n        _assertClass(cose_sign, COSESign);\n        const ret = wasm.signedmessage_new_cose_sign(cose_sign.ptr);\n        return SignedMessage.__wrap(ret);\n    }\n    /**\n     * @param {COSESign1} cose_sign1\n     * @returns {SignedMessage}\n     */\n    static new_cose_sign1(cose_sign1) {\n        _assertClass(cose_sign1, COSESign1);\n        const ret = wasm.signedmessage_new_cose_sign1(cose_sign1.ptr);\n        return SignedMessage.__wrap(ret);\n    }\n    /**\n     * @param {string} s\n     * @returns {SignedMessage}\n     */\n    static from_user_facing_encoding(s) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.signedmessage_from_user_facing_encoding(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return SignedMessage.__wrap(r0);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {string}\n     */\n    to_user_facing_encoding() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signedmessage_to_user_facing_encoding(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n     * @returns {number}\n     */\n    kind() {\n        const ret = wasm.signedmessage_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {COSESign | undefined}\n     */\n    as_cose_sign() {\n        const ret = wasm.signedmessage_as_cose_sign(this.ptr);\n        return ret === 0 ? undefined : COSESign.__wrap(ret);\n    }\n    /**\n     * @returns {COSESign1 | undefined}\n     */\n    as_cose_sign1() {\n        const ret = wasm.signedmessage_as_cose_sign1(this.ptr);\n        return ret === 0 ? undefined : COSESign1.__wrap(ret);\n    }\n}\nconst TaggedCBORFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_taggedcbor_free(ptr));\n/** */\nexport class TaggedCBOR {\n    static __wrap(ptr) {\n        const obj = Object.create(TaggedCBOR.prototype);\n        obj.ptr = ptr;\n        TaggedCBORFinalization.register(obj, obj.ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        TaggedCBORFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_taggedcbor_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.taggedcbor_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {TaggedCBOR}\n     */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.taggedcbor_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TaggedCBOR.__wrap(r0);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {BigNum}\n     */\n    tag() {\n        const ret = wasm.taggedcbor_tag(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n     * @returns {CBORValue}\n     */\n    value() {\n        const ret = wasm.taggedcbor_value(this.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n     * @param {BigNum} tag\n     * @param {CBORValue} value\n     * @returns {TaggedCBOR}\n     */\n    static new(tag, value) {\n        _assertClass(tag, BigNum);\n        var ptr0 = tag.__destroy_into_raw();\n        _assertClass(value, CBORValue);\n        const ret = wasm.taggedcbor_new(ptr0, value.ptr);\n        return TaggedCBOR.__wrap(ret);\n    }\n}\nconst imports = {\n    __wbindgen_placeholder__: {\n        __wbindgen_object_drop_ref: function (arg0) {\n            takeObject(arg0);\n        },\n        __wbindgen_string_new: function (arg0, arg1) {\n            const ret = getStringFromWasm0(arg0, arg1);\n            return addHeapObject(ret);\n        },\n        __wbindgen_debug_string: function (arg0, arg1) {\n            const ret = debugString(getObject(arg1));\n            const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            getInt32Memory0()[arg0 / 4 + 1] = len0;\n            getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n        },\n        __wbindgen_throw: function (arg0, arg1) {\n            throw new Error(getStringFromWasm0(arg0, arg1));\n        },\n    },\n};\n/**\n * Decompression callback\n *\n * @callback DecompressCallback\n * @param {Uint8Array} compressed\n * @return {Uint8Array} decompressed\n */\n/**\n * Options for instantiating a Wasm instance.\n * @typedef {Object} InstantiateOptions\n * @property {URL=} url - Optional url to the Wasm file to instantiate.\n * @property {DecompressCallback=} decompress - Callback to decompress the\n * raw Wasm file bytes before instantiating.\n */\n/** Instantiates an instance of the Wasm module returning its functions.\n * @remarks It is safe to call this multiple times and once successfully\n * loaded it will always return a reference to the same object.\n * @param {InstantiateOptions=} opts\n */\nexport async function instantiate(opts) {\n    return (await instantiateWithInstance(opts)).exports;\n}\nlet instanceWithExports;\nlet lastLoadPromise;\n/** Instantiates an instance of the Wasm module along with its exports.\n * @remarks It is safe to call this multiple times and once successfully\n * loaded it will always return a reference to the same object.\n * @param {InstantiateOptions=} opts\n * @returns {Promise<{\n *   instance: WebAssembly.Instance;\n *   exports: { BigNum : typeof BigNum ; CBORArray : typeof CBORArray ; CBORObject : typeof CBORObject ; CBORSpecial : typeof CBORSpecial ; CBORValue : typeof CBORValue ; COSEEncrypt : typeof COSEEncrypt ; COSEEncrypt0 : typeof COSEEncrypt0 ; COSEKey : typeof COSEKey ; COSERecipient : typeof COSERecipient ; COSERecipients : typeof COSERecipients ; COSESign : typeof COSESign ; COSESign1 : typeof COSESign1 ; COSESign1Builder : typeof COSESign1Builder ; COSESignBuilder : typeof COSESignBuilder ; COSESignature : typeof COSESignature ; COSESignatures : typeof COSESignatures ; CounterSignature : typeof CounterSignature ; EdDSA25519Key : typeof EdDSA25519Key ; HeaderMap : typeof HeaderMap ; Headers : typeof Headers ; Int : typeof Int ; Label : typeof Label ; Labels : typeof Labels ; PasswordEncryption : typeof PasswordEncryption ; ProtectedHeaderMap : typeof ProtectedHeaderMap ; PubKeyEncryption : typeof PubKeyEncryption ; SigStructure : typeof SigStructure ; SignedMessage : typeof SignedMessage ; TaggedCBOR : typeof TaggedCBOR  }\n * }>}\n */\nexport function instantiateWithInstance(opts) {\n    if (instanceWithExports != null) {\n        return Promise.resolve(instanceWithExports);\n    }\n    if (lastLoadPromise == null) {\n        lastLoadPromise = (async () => {\n            try {\n                const instance = (await instantiateModule(opts ?? {})).instance;\n                wasm = instance.exports;\n                cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n                cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n                instanceWithExports = {\n                    instance,\n                    exports: getWasmInstanceExports(),\n                };\n                return instanceWithExports;\n            }\n            finally {\n                lastLoadPromise = null;\n            }\n        })();\n    }\n    return lastLoadPromise;\n}\nfunction getWasmInstanceExports() {\n    return {\n        BigNum,\n        CBORArray,\n        CBORObject,\n        CBORSpecial,\n        CBORValue,\n        COSEEncrypt,\n        COSEEncrypt0,\n        COSEKey,\n        COSERecipient,\n        COSERecipients,\n        COSESign,\n        COSESign1,\n        COSESign1Builder,\n        COSESignBuilder,\n        COSESignature,\n        COSESignatures,\n        CounterSignature,\n        EdDSA25519Key,\n        HeaderMap,\n        Headers,\n        Int,\n        Label,\n        Labels,\n        PasswordEncryption,\n        ProtectedHeaderMap,\n        PubKeyEncryption,\n        SigStructure,\n        SignedMessage,\n        TaggedCBOR,\n    };\n}\n/** Gets if the Wasm module has been instantiated. */\nexport function isInstantiated() {\n    return instanceWithExports != null;\n}\n/**\n * @param {InstantiateOptions} opts\n */\nasync function instantiateModule(opts) {\n    // Temporary exception for fresh framework\n    const wasmUrl = import.meta.url.includes(\"_frsh\")\n        ? opts.url\n        : new URL(\"cardano_message_signing_bg.wasm\", import.meta.url);\n    const decompress = opts.decompress;\n    const isFile = wasmUrl.protocol === \"file:\";\n    // make file urls work in Node via dnt\n    const isNode = globalThis.process?.versions?.node != null;\n    if (isNode && isFile) {\n        // requires fs to be set externally on globalThis\n        const wasmCode = fs.readFileSync(wasmUrl);\n        return WebAssembly.instantiate(decompress ? decompress(wasmCode) : wasmCode, imports);\n    }\n    switch (wasmUrl.protocol) {\n        case \"\": // relative URL\n        case \"chrome-extension:\":\n        case \"file:\":\n        case \"https:\":\n        case \"http:\": {\n            if (isFile) {\n                if (typeof Deno !== \"object\") {\n                    throw new Error(\"file urls are not supported in this environment\");\n                }\n                if (\"permissions\" in Deno) {\n                    await Deno.permissions.request({ name: \"read\", path: wasmUrl });\n                }\n            }\n            else if (typeof Deno === \"object\" && \"permissions\" in Deno) {\n                await Deno.permissions.request({ name: \"net\", host: wasmUrl.host });\n            }\n            const wasmResponse = await fetch(wasmUrl);\n            if (decompress) {\n                const wasmCode = new Uint8Array(await wasmResponse.arrayBuffer());\n                return WebAssembly.instantiate(decompress(wasmCode), imports);\n            }\n            if (isFile ||\n                wasmResponse.headers.get(\"content-type\")?.toLowerCase()\n                    .startsWith(\"application/wasm\")) {\n                return WebAssembly.instantiateStreaming(wasmResponse, imports);\n            }\n            else {\n                return WebAssembly.instantiate(await wasmResponse.arrayBuffer(), imports);\n            }\n        }\n        default:\n            throw new Error(`Unsupported protocol: ${wasmUrl.protocol}`);\n    }\n}\n"],"names":["wasm","heap","Array","fill","undefined","getObject","idx","push","heap_next","length","dropObject","takeObject","ret","cachedTextDecoder","TextDecoder","ignoreBOM","fatal","decode","cachedUint8Memory0","getUint8Memory0","byteLength","Uint8Array","memory","buffer","getStringFromWasm0","ptr","len","subarray","addHeapObject","obj","debugString","val","type","description","name","isArray","debug","i","builtInMatches","exec","toString","call","className","JSON","stringify","_","Error","message","stack","WASM_VECTOR_LEN","cachedTextEncoder","TextEncoder","encodeString","arg","view","encodeInto","passStringToWasm0","malloc","realloc","buf","encode","set","mem","offset","code","charCodeAt","slice","written","cachedInt32Memory0","getInt32Memory0","Int32Array","_assertClass","instance","klass","passArray8ToWasm0","getArrayU8FromWasm0","cachedFloat64Memory0","getFloat64Memory0","Float64Array","isLikeNone","x","AlgorithmId","Object","freeze","EdDSA","ChaCha20Poly1305","KeyType","OKP","EC2","Symmetric","ECKey","CRV","X","Y","D","CurveType","P256","P384","P521","X25519","X448","Ed25519","Ed448","KeyOperation","Sign","Verify","Encrypt","Decrypt","WrapKey","UnwrapKey","DeriveKey","DeriveBits","CBORSpecialType","Bool","Float","Unassigned","Break","Undefined","Null","CBORValueKind","Int","Bytes","Text","TaggedCBOR","Special","LabelKind","SignedMessageKind","COSESIGN","COSESIGN1","SigContext","Signature","Signature1","CounterSignature","BigNumFinalization","FinalizationRegistry","__wbg_bignum_free","BigNum","__wrap","create","prototype","register","__destroy_into_raw","this","unregister","free","to_bytes","retptr","__wbindgen_add_to_stack_pointer","bignum_to_bytes","r0","r1","v0","__wbindgen_free","from_bytes","bytes","ptr0","__wbindgen_malloc","len0","bignum_from_bytes","r2","from_str","string","__wbindgen_realloc","bignum_from_str","to_str","bignum_to_str","checked_mul","other","bignum_checked_mul","checked_add","bignum_checked_add","checked_sub","bignum_checked_sub","CBORArrayFinalization","__wbg_cborarray_free","CBORArray","cborarray_to_bytes","cborarray_from_bytes","new","cborarray_new","cborarray_len","get","index","cborarray_get","CBORValue","add","elem","cborarray_add","set_definite_encoding","use_definite","cborarray_set_definite_encoding","is_definite","cborarray_is_definite","CBORObjectFinalization","__wbg_cborobject_free","CBORObject","cborobject_to_bytes","cborobject_from_bytes","cborobject_new","cborobject_len","insert","key","value","cborobject_insert","cborobject_get","keys","cborobject_keys","cborobject_set_definite_encoding","cborobject_is_definite","CBORSpecialFinalization","__wbg_cborspecial_free","CBORSpecial","cborspecial_to_bytes","cborspecial_from_bytes","new_bool","b","cborspecial_new_bool","new_unassigned","u","cborspecial_new_unassigned","new_break","cborspecial_new_break","new_null","cborspecial_new_null","new_undefined","cborspecial_new_undefined","kind","cborspecial_kind","as_bool","cborspecial_as_bool","as_float","cborspecial_as_float","as_unassigned","cborspecial_as_unassigned","CBORValueFinalization","__wbg_cborvalue_free","cborvalue_to_bytes","cborvalue_from_bytes","new_int","int","cborvalue_new_int","new_bytes","cborvalue_new_bytes","new_text","text","cborvalue_new_text","new_array","arr","cborvalue_new_array","new_object","cborvalue_new_object","new_tagged","tagged","cborvalue_new_tagged","new_special","special","cborvalue_new_special","from_label","label","Label","cborvalue_from_label","cborvalue_kind","as_int","cborvalue_as_int","as_bytes","cborvalue_as_bytes","as_text","cborvalue_as_text","as_array","cborvalue_as_array","as_object","cborvalue_as_object","as_tagged","cborvalue_as_tagged","as_special","cborvalue_as_special","COSEEncryptFinalization","__wbg_coseencrypt_free","COSEEncrypt","coseencrypt_to_bytes","coseencrypt_from_bytes","headers","coseencrypt0_headers","Headers","ciphertext","coseencrypt0_ciphertext","recipients","coseencrypt_recipients","COSERecipients","coseencrypt_new","COSEEncrypt0Finalization","__wbg_coseencrypt0_free","COSEEncrypt0","coseencrypt0_to_bytes","coseencrypt0_from_bytes","coseencrypt0_new","COSEKeyFinalization","__wbg_cosekey_free","COSEKey","cosekey_to_bytes","cosekey_from_bytes","set_key_type","key_type","cosekey_set_key_type","cosekey_key_type","set_key_id","key_id","cosekey_set_key_id","cosekey_key_id","set_algorithm_id","algorithm_id","cosekey_set_algorithm_id","cosekey_algorithm_id","set_key_ops","key_ops","Labels","cosekey_set_key_ops","cosekey_key_ops","set_base_init_vector","base_init_vector","cosekey_set_base_init_vector","cosekey_base_init_vector","header","cosekey_header","set_header","cosekey_set_header","cosekey_new","COSERecipientFinalization","__wbg_coserecipient_free","COSERecipient","coserecipient_to_bytes","coserecipient_from_bytes","COSERecipientsFinalization","__wbg_coserecipients_free","coserecipients_to_bytes","coserecipients_from_bytes","coserecipients_new","coserecipients_get","coserecipients_add","COSESignFinalization","__wbg_cosesign_free","COSESign","cosesign_to_bytes","cosesign_from_bytes","payload","signatures","cosesign_signatures","COSESignatures","cosesign_new","COSESign1Finalization","__wbg_cosesign1_free","COSESign1","cosesign1_to_bytes","cosesign1_from_bytes","signature","cosesign1_signature","signed_data","external_aad","external_payload","ptr1","len1","cosesign1_signed_data","SigStructure","cosesign1_new","COSESign1BuilderFinalization","__wbg_cosesign1builder_free","COSESign1Builder","is_payload_external","cosesign1builder_new","hash_payload","cosesign1builder_hash_payload","set_external_aad","cosesign1builder_set_external_aad","make_data_to_sign","cosesign1builder_make_data_to_sign","build","signed_sig_structure","cosesign1builder_build","COSESignBuilderFinalization","__wbg_cosesignbuilder_free","COSESignBuilder","cosesignbuilder_new","cosesignbuilder_make_data_to_sign","cosesignbuilder_build","COSESignatureFinalization","__wbg_cosesignature_free","COSESignature","cosesignature_to_bytes","cosesignature_from_bytes","cosesignature_signature","cosesignature_new","COSESignaturesFinalization","__wbg_cosesignatures_free","cosesignatures_to_bytes","cosesignatures_from_bytes","cosesignatures_get","cosesignatures_add","CounterSignatureFinalization","__wbg_countersignature_free","countersignature_to_bytes","countersignature_from_bytes","new_single","cose_signature","countersignature_new_single","new_multi","cose_signatures","countersignature_new_multi","countersignature_signatures","EdDSA25519KeyFinalization","__wbg_eddsa25519key_free","EdDSA25519Key","pubkey_bytes","eddsa25519key_new","set_private_key","private_key_bytes","eddsa25519key_set_private_key","is_for_signing","eddsa25519key_is_for_signing","is_for_verifying","eddsa25519key_is_for_verifying","eddsa25519key_build","HeaderMapFinalization","__wbg_headermap_free","HeaderMap","headermap_to_bytes","headermap_from_bytes","headermap_set_algorithm_id","headermap_algorithm_id","set_criticality","criticality","headermap_set_criticality","headermap_criticality","set_content_type","content_type","headermap_set_content_type","headermap_content_type","headermap_set_key_id","headermap_key_id","set_init_vector","init_vector","set_partial_init_vector","partial_init_vector","headermap_set_partial_init_vector","headermap_partial_init_vector","set_counter_signature","counter_signature","headermap_set_counter_signature","headermap_counter_signature","headermap_header","headermap_set_header","headermap_keys","headermap_new","HeadersFinalization","__wbg_headers_free","headers_to_bytes","headers_from_bytes","protected","headers_protected","ProtectedHeaderMap","unprotected","headers_unprotected","protected_","unprotected_","headers_new","IntFinalization","__wbg_int_free","int_new","new_negative","int_new_negative","new_i32","int_new_i32","is_positive","int_is_positive","as_positive","int_as_positive","as_negative","int_as_negative","as_i32","int_as_i32","LabelFinalization","__wbg_label_free","label_to_bytes","label_from_bytes","label_new_int","label_new_text","label_kind","label_as_int","label_as_text","from_algorithm_id","id","label_from_algorithm_id","from_key_type","label_from_key_type","from_ec_key","ec_key","label_from_ec_key","from_curve_type","curve_type","label_from_curve_type","from_key_operation","key_op","label_from_key_operation","LabelsFinalization","__wbg_labels_free","labels_to_bytes","labels_from_bytes","labels_get","labels_add","PasswordEncryptionFinalization","__wbg_passwordencryption_free","PasswordEncryption","passwordencryption_to_bytes","passwordencryption_from_bytes","data","passwordencryption_new","ProtectedHeaderMapFinalization","__wbg_protectedheadermap_free","protectedheadermap_to_bytes","protectedheadermap_from_bytes","new_empty","protectedheadermap_new_empty","header_map","protectedheadermap_new","deserialized_headers","protectedheadermap_deserialized_headers","PubKeyEncryptionFinalization","__wbg_pubkeyencryption_free","PubKeyEncryption","pubkeyencryption_to_bytes","pubkeyencryption_from_bytes","pubkeyencryption_new","SigStructureFinalization","__wbg_sigstructure_free","sigstructure_to_bytes","sigstructure_from_bytes","context","sigstructure_context","body_protected","sigstructure_body_protected","sign_protected","sigstructure_sign_protected","sigstructure_external_aad","sigstructure_payload","set_sign_protected","sigstructure_set_sign_protected","sigstructure_new","SignedMessageFinalization","__wbg_signedmessage_free","SignedMessage","signedmessage_to_bytes","signedmessage_from_bytes","new_cose_sign","cose_sign","signedmessage_new_cose_sign","new_cose_sign1","cose_sign1","signedmessage_new_cose_sign1","from_user_facing_encoding","s","signedmessage_from_user_facing_encoding","to_user_facing_encoding","signedmessage_to_user_facing_encoding","signedmessage_kind","as_cose_sign","signedmessage_as_cose_sign","as_cose_sign1","signedmessage_as_cose_sign1","TaggedCBORFinalization","__wbg_taggedcbor_free","taggedcbor_to_bytes","taggedcbor_from_bytes","tag","taggedcbor_tag","taggedcbor_value","taggedcbor_new","imports","__wbindgen_placeholder__","__wbindgen_object_drop_ref","arg0","__wbindgen_string_new","arg1","__wbindgen_debug_string","__wbindgen_throw","async","instantiate","opts","instantiateWithInstance","exports","instanceWithExports","lastLoadPromise","Promise","resolve","instantiateModule","getWasmInstanceExports","isInstantiated","wasmUrl","import","includes","url","URL","decompress","isFile","protocol","isNode","globalThis","process","versions","node","wasmCode","fs","readFileSync","WebAssembly","Deno","permissions","request","path","host","wasmResponse","fetch","arrayBuffer","toLowerCase","startsWith","instantiateStreaming"],"sourceRoot":""}